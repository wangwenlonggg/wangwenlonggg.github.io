<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"wangwenlonggg.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="wangwenlonggg">
<meta property="og:url" content="http://wangwenlonggg.github.io/index.html">
<meta property="og:site_name" content="wangwenlonggg">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="wangwenlonggg">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://wangwenlonggg.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>wangwenlonggg</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">wangwenlonggg</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://wangwenlonggg.github.io/2021/05/24/%E7%9B%B8%E6%9C%BA%E6%A0%87%E5%AE%9A%EF%BC%88camera-calibration%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/laugh.jpg">
      <meta itemprop="name" content="wangwenlonggg">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wangwenlonggg">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/24/%E7%9B%B8%E6%9C%BA%E6%A0%87%E5%AE%9A%EF%BC%88camera-calibration%EF%BC%89/" class="post-title-link" itemprop="url">相机标定（camera calibration）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-05-24 13:01:51 / 修改时间：17:25:38" itemprop="dateCreated datePublished" datetime="2021-05-24T13:01:51+08:00">2021-05-24</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/3D-reconstruction/" itemprop="url" rel="index"><span itemprop="name">3D reconstruction</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="相机标定的目的和意义">相机标定的目的和意义</h2>
<p>我们所处的世界是三维的，而照片是二维的，这样我们可以把相机认为是一个函数，输入量是一个场景，输出量是一幅灰度图。这个从三维到二维的过程的函数是不可逆的。</p>
<p><img src="/2021/05/24/%E7%9B%B8%E6%9C%BA%E6%A0%87%E5%AE%9A%EF%BC%88camera-calibration%EF%BC%89/v2-a471b2757c15580c127769261e52a441_r.png"></p>
<p>相机标定的目标是我们找一个合适的数学模型，求出这个模型的参数，这样我们能够近似这个三维到二维的过程，使这个三维到二维的过程的函数找到反函数。</p>
<p><img src="/2021/05/24/%E7%9B%B8%E6%9C%BA%E6%A0%87%E5%AE%9A%EF%BC%88camera-calibration%EF%BC%89/v2-afff3b4901966569a5203751afb5e50f_r.jpg"></p>
<p>这个逼近的过程就是「相机标定」，我们用简单的数学模型来表达复杂的成像过程，并且求出成像的反过程。标定之后的相机，可以进行三维场景的重建，即深度的感知，这是计算机视觉的一大分支。</p>
<p>基本的坐标系： - 世界坐标系(world coordinate system) - 相机坐标系(camera coordinate system) - 图像坐标系(image coordinate system)</p>
<p>一般来说，标定的过程分为两个部分： - 第一步是从世界坐标系转换为相机坐标系，这一步是三维点到三维点的转换，包括 R RR，t tt （相机外参）等参数。 - 第二部是从相机坐标系转为图像坐标系，这一步是三维点到二维点的转换，包括 K KK（相机内参）等参数。</p>
<h2 id="相机坐标系转换到图像坐标系">相机坐标系转换到图像坐标系</h2>
<h3 id="坐标系介绍">坐标系介绍</h3>
<p><img src="/2021/05/24/%E7%9B%B8%E6%9C%BA%E6%A0%87%E5%AE%9A%EF%BC%88camera-calibration%EF%BC%89/9c3151f32b104bd09a105b1efc663f32.png"></p>
<ul>
<li>C 点表示camera centre，即相机的中心点，也是相机坐标系的中心点；</li>
<li>Z 轴表示principal axis，即相机的主轴；</li>
<li>p 点所在的平面表示image plane，即相机的像平面，也就是图片坐标系所在的二维平面；</li>
<li>p 点表示principal point，即主点，主轴与像平面相交的点；</li>
<li>C 点到 p pp 点的距离，也就是右边图中的 f ff 表示focal length，即相机的焦距；</li>
<li>像平面上的 x 和 y 坐标轴是与相机坐标系上的 X 和 Y 坐标轴互相平行的；</li>
<li>相机坐标系是以 X ，Y ，Z 三个轴组成的且原点在 C 点，度量值为米(m)；</li>
<li>像平面坐标系是以 x，y（小写）两个轴组成的且原点在 p 点，度量值为米(m)；</li>
<li>图像坐标系一般指图片相对坐标系，在这里可以认为和像平面坐标系在一个平面上，不过相平面坐标系的原点是在图片的角上，而且度量值为像素的个数(pixel)；</li>
</ul>
<h3 id="相机转换到像平面">相机转换到像平面</h3>
<p>如果知道相机坐标系中的一个点X（现实三维世界中的点），在像平面坐标系对应的点是 x，要求求从相机坐标系转为像平面坐标系的转换，也就是从X点的( X , Y , Z )通过一定的转换变为x点的(x, y)。</p>
<p>注意( X , Y , Z )是在相机坐标系，而( x , y )是在像平面坐标系（还不是图像坐标系，因为原点不同。）观察第二个图，很简单的可以得到这个转换：</p>
<p><span class="math display">\[
x = \frac{fX}{Z}
\]</span></p>
<p><span class="math display">\[
y = \frac{fY}{Z}
\]</span></p>
<p><span class="math display">\[
(X, Y, Z)\longrightarrow (\frac{fX}{Z}, \frac{fY}{Z})
\]</span></p>
<p>可以表示为矩阵计算为（在这里用的是齐次坐标的表示方式，关于齐次坐标文章最下面有介绍）：</p>
<p><span class="math display">\[
\begin{bmatrix}
X \\ Y \\ Z \\ 1 
\end{bmatrix} \longrightarrow 
\begin{bmatrix}
fX \\ fY \\ Z
\end{bmatrix} = 
\begin{bmatrix}
f&amp;&amp;&amp;0 \\ &amp;f&amp;&amp;0 \\ &amp;&amp;1&amp;0
\end{bmatrix}
\begin{bmatrix}
X \\ Y \\ Z \\ 1 
\end{bmatrix}
\]</span></p>
<p>可以简写为（P就是所谓的投影矩阵，当然现在还不完整）：</p>
<p><span class="math display">\[
x = PX 
\]</span></p>
<h3 id="加入偏移量">加入偏移量</h3>
<p>通过上面，可以把相机坐标系转换到像平面坐标系，但是像平面坐标系和图像坐标系虽然在同一个平面上，但是原点并不是同一个，而目标是要转换到图像坐标系下，所以还需要一步操作，如下图：</p>
<p><img src="/2021/05/24/%E7%9B%B8%E6%9C%BA%E6%A0%87%E5%AE%9A%EF%BC%88camera-calibration%EF%BC%89/69c2ab944924e3dc2baef495d5295828.png"></p>
<p>如上图所示，其中主点 p 是像平面坐标系的原点，但在图像坐标系中的位置为</p>
<p><span class="math display">\[
(p_{x}, p_{y})
\]</span></p>
<p>在这里，图形坐标系的原点是图片的左下角，所以可以得到：</p>
<p><span class="math display">\[
(X, Y, Z) \longrightarrow (\frac{fX}{Z} + p_{x}, \frac{fY}{Z} + p_{y},)
\]</span></p>
<p>相当于在上面的基础上加了一个p点坐标的偏移量，同时可以表示为矩阵计算为（在这里用的是齐次坐标的表示方式）：</p>
<p><span class="math display">\[
\begin{bmatrix}
X \\ Y \\ Z \\ 1 
\end{bmatrix} \longrightarrow 
\begin{bmatrix}
fX + Zp_{x} \\ fY + Zp_{y} \\ Z
\end{bmatrix} = 
\begin{bmatrix}
f&amp;&amp;p_{x}&amp;0 \\ &amp;f&amp;p_{y}&amp; \\ &amp;&amp;1&amp;0
\end{bmatrix}
\begin{bmatrix}
X \\ Y \\ Z \\ 1 
\end{bmatrix}
\]</span></p>
<p>整理一下得：</p>
<p><span class="math display">\[
\begin{bmatrix}
fX + Zp_{x} \\ fY + Zp_{y} \\ Z
\end{bmatrix} = 
\begin{bmatrix}
f&amp;&amp;p_{x} \\ &amp;f&amp;p_{y} \\ &amp;&amp;1
\end{bmatrix}
\begin{bmatrix}
1&amp;&amp;&amp;0 \\ &amp;1&amp;&amp;0 \\ &amp;&amp;1&amp;0
\end{bmatrix}
\begin{bmatrix}
X \\ Y \\ Z \\ 1 
\end{bmatrix}
\]</span></p>
<p>所以最后可以得到 K，也就是平时所说的相机内参（Intrinsic parameters）：</p>
<p><span class="math display">\[
\begin{bmatrix}
f&amp;&amp;p_{x} \\ &amp;f&amp;p_{y} \\ &amp;&amp;1
\end{bmatrix}
\]</span></p>
<p>以及投影矩阵P（在这里可以认为旋转矩阵R为单位矩阵I，平移矩阵t都为0，这也是为什么要拆成这种方式），为：</p>
<p><span class="math display">\[
P = K[I \  \rvert \ 0]
\]</span></p>
<h3 id="像素坐标">像素坐标</h3>
<p>前面也提到了在图像坐标系中用的不是现实生活中的m来度量，而是用的 pixel 的个数，所以在上面转换到图像坐标系中还有个问题，就是坐标的表示还是m，并没有转换到像素坐标系统；在这里需要引入一个新概念就是： - <span class="math inline">\(m_{x}\)</span>表示在水平方向1m的长度包含的像素的个数; - <span class="math inline">\(m_{y}\)</span>表示在竖直方向1m的长度包含的像素的个数;</p>
<p>可能有人奇怪为啥不是一个值，还需要分别指定 <span class="math inline">\(m_{x}\)</span>,<span class="math inline">\(m_{y}\)</span>呀，这是因为通过上面可以得到一个像素点的大小（m度量）为：</p>
<p><span class="math display">\[
\frac{1}{m_{x}} \times \frac{1}{m_{y}}
\]</span></p>
<p>需要说明的是像素并不一定是一个正方形，有时候可能也是一个矩形，所以要分别指定。 所以可以把上面相机内参 K 变为更新为，转换公式把 K 替换即可，其他不变：</p>
<p><span class="math display">\[
K = \begin{bmatrix}
m_{x}&amp;&amp; \\ &amp;m_{y}&amp; \\ &amp;&amp;1 \end{bmatrix}
\begin{bmatrix}
f&amp;&amp;p_{x} \\ &amp;f&amp;p_{y} \\ &amp;&amp;1 \end{bmatrix} = 
\begin{bmatrix}
\alpha _{x} &amp;&amp;\beta _{x} \\ &amp;\alpha _{y}&amp;\beta _{y} \\ &amp;&amp;1 \end{bmatrix}
\]</span></p>
<h2 id="世界坐标系转换到图像坐标系">世界坐标系转换到图像坐标系</h2>
<h3 id="坐标系介绍-1">坐标系介绍</h3>
<p><img src="/2021/05/24/%E7%9B%B8%E6%9C%BA%E6%A0%87%E5%AE%9A%EF%BC%88camera-calibration%EF%BC%89/f3639e2ffd0767171634ad603c7ad0c6.png"></p>
<p>如上图所示，从世界坐标系转换到相机坐标系是三维空间到三维空间的变换，一般来说需要一个平移操作和一个旋转操作就可以完成这个转换，用公式表示如下（可以理解为世界坐标系原点先平移到相机坐标系的位置然后在做一次坐标系旋转，使坐标轴对齐。）</p>
<p><span class="math display">\[
\tilde{X}_{cam} = R(\tilde{X} \ - \ \tilde{C})
\]</span></p>
<ul>
<li>R 表示旋转矩阵;</li>
<li><span class="math inline">\(\tilde{X}\)</span>表示 X 点在世界坐标系中的位置;</li>
<li><span class="math inline">\(\tilde{C}\)</span>表示相机原点 C 在世界坐标系中的位置;</li>
<li><span class="math inline">\(\tilde{X}_{cam}\)</span>表示 X 点在相机坐标系中的位置;</li>
</ul>
<h3 id="世界转换到相机">世界转换到相机</h3>
<p>根据上面的公式可以得到从一个三维点从世界坐标系转换到相机坐标的变换公式如下（也是用的齐次坐标的表示方式）：</p>
<p><span class="math display">\[
X_{cam} = \begin{bmatrix} 
\tilde{X}_{cam} \\ 1 \end{bmatrix} = 
\begin{bmatrix}
R&amp;-R\tilde{C} \\ 0&amp;1 \end{bmatrix}
\begin{bmatrix}
\tilde{X} \\ 1 \end{bmatrix} = 
\begin{bmatrix}
R&amp;-R\tilde{C} \\ 0&amp;1 \end{bmatrix}X
\]</span></p>
<h3 id="世界转换到图像">世界转换到图像</h3>
<p>根据上面的讨论知道了怎样从世界坐标系转换到相机坐标系（平移和旋转）以及从相机坐标系转换到图像坐标系（相机内参变换），所以带入上面的矩阵计算，可以得到：</p>
<p><span class="math display">\[
x = K[I \ | \ 0]X_{cam} = K[R \ | \ -R\tilde{C}] X
\]</span></p>
<p>这样就得到了最终的投影矩阵 P:</p>
<p><span class="math display">\[
P = K[R \ | \ t]
\]</span></p>
<p>其中：</p>
<p><span class="math display">\[
t = -R\tilde{C}
\]</span></p>
<p>在这里，K 一般称为相机内参（intrinsic parameters），描述了相机的内部参数，包括焦距 f 、主点 p 的位置、以及像素与真实环境的大小比例等，这个是固有属性，是提供好的；R 和 t 称为相机外参（extrinsic parameters），R 在这里是旋转矩阵，可以转换为三维的旋转向量，分别表示绕x ，y ，z 三个轴的旋转角度，t 目前就是一个平移向量，分别表示在x ，y ，z 三个方向上的平移量。</p>
<h2 id="畸变参数distortion-parameters">畸变参数(distortion parameters)</h2>
<p>在几何光学和阴极射线管(CRT)显示中，畸变（distortion） 是对直线投影（rectilinear projection）的一种偏移。简单来说直线投影是场景内的一条直线投影到图片上也保持为一条直线。那畸变简单来说就是一条直线投影到图片上不能保持为一条直线了，这是一种光学畸变（optical aberration）。可能由于摄像机镜头的原因，这里不讨论，有兴趣的可以查阅光学畸变的相关的资料。 畸变一般可以分为两大类，包括径向畸变和切向畸变。主要的一般径向畸变有时也会有轻微的切向畸变。</p>
<h3 id="径向畸变radial-distortion">径向畸变（Radial distortion）</h3>
<p>径向畸变的效应有三种，一种是桶形畸变（barrel distortion），另一种是枕形畸变（pincushion distortion），还有一种是两种的结合叫做胡子畸变（mustache distortion），从图片中可以很容易看出区别，具体见下图:</p>
<p><img src="/2021/05/24/%E7%9B%B8%E6%9C%BA%E6%A0%87%E5%AE%9A%EF%BC%88camera-calibration%EF%BC%89/09ea55c6320d551fc0cafe2d32beb5dd.png"></p>
<p>径向畸变可以用如下公式修正：</p>
<p><span class="math display">\[
x_{corr} = x_{dis}(1+k_{1}r^{2}+k_{2}r^{4}+k_{3}r^{6})
\]</span> <span class="math display">\[
y_{corr} = y_{dis}(1+k_{1}r^{2}+k_{2}r^{4}+k_{3}r^{6})
\]</span></p>
<h3 id="切向畸变tangential-distortion">切向畸变（tangential distortion）</h3>
<p>切向畸变是由于透镜与成像平面不严格的平行，其可以用如下公式修正：</p>
<p><span class="math display">\[
x_{corr} = x_{dis}+[2p_{1}xy+p_{2}(r^{2}+2x^{2})]
\]</span> <span class="math display">\[
y_{corr} = y_{dis}+[2p_{2}xy+p_{1}(r^{2}+2y^{2})]
\]</span></p>
<p>其中： - <span class="math inline">\(x_{dis}\)</span>和<span class="math inline">\(y_{dis}\)</span>表示有畸变的坐标; - <span class="math inline">\(x_{corr}\)</span>和<span class="math inline">\(y_{corr}\)</span>表示修复后的坐标; - <span class="math inline">\(k_{1},k_{2},k_{3}\)</span>表示径向畸变参数; - <span class="math inline">\(p_{1},p_{2}\)</span>表示切向畸变参数;</p>
<p>所以最终得到5个畸变参数：</p>
<p><span class="math display">\[
D=(k_{1},k_{2},p_{1},p_{2},k_{3})
\]</span></p>
<h2 id="齐次坐标">齐次坐标</h2>
<p>就是将一个原本是n维的向量用一个n+1维向量来表示。 许多图形应用涉及到几何变换，主要包括平移、旋转、缩放。以矩阵表达式来计算这些变换时，平移是矩阵相加，旋转和缩放则是矩阵相乘，综合起来可以表示为 x = R ∗ X + t （注：因为习惯的原因，实际使用时一般使用变化矩阵左乘向量）(R 旋转缩放矩阵，t 为平移矩阵，X 为原向量，x 为变换后的向量)。引入齐次坐标的目的主要是合并矩阵运算中的乘法和加法，表示为 x = P ∗ X 的形式。即它提供了用矩阵运算把二维、三维甚至高维空间中的一个点集从一个坐标系变换到另一个坐标系的有效方法。和上面的计算过程是对应的。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://wangwenlonggg.github.io/2021/05/22/%E7%89%A9%E7%90%86%E5%B1%82/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/laugh.jpg">
      <meta itemprop="name" content="wangwenlonggg">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wangwenlonggg">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/22/%E7%89%A9%E7%90%86%E5%B1%82/" class="post-title-link" itemprop="url">物理层</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-05-22 13:30:39" itemprop="dateCreated datePublished" datetime="2021-05-22T13:30:39+08:00">2021-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-23 11:20:41" itemprop="dateModified" datetime="2021-05-23T11:20:41+08:00">2021-05-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">计算机网络</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="物理层的概念">物理层的概念</h3>
<p>  物理层是计算机网络的第一层，它虽然处于最底层，却是整个开放系统的基础。物理层为设备之间的数据通信提供传输媒体及互连设备，为数据传输提供可靠的环境。<br>
  物理层规定传输数据所需要的物理链路创建、维持、拆除，而提供具有<strong>机械的，电气的，功能的和规程的</strong>特性，主要关心如何传输信号。<br>
  比如说我们通常知道数字信号其实是由0和1组成的，那么我们是怎么规定0和1的（电压大小），如何确保0和1在传输过程中种种干扰的准确性（传输媒体、编码方式等）。其实物理层的相关知识，仅仅包含通讯信号的特性（机械特性、电气特性、 功能特性、过程特性），但传输媒体实体并不属于物理层。</p>
<h3 id="物理层要解决的主要问题">物理层要解决的主要问题</h3>
<ol type="1">
<li>物理层要尽可能地屏蔽掉物理设备和传输媒体，通信手段的不同，使数据链路层感觉不到这些差异，只考虑完成本层的协议和服务。</li>
<li>给其服务用户（数据链路层）在一条物理的传输媒体上传送和接收比特流（一般为串行按顺序传输的比特流）的能力，为此，物理层应该解决物理连接的建立、维持和释放问题。</li>
<li>在两个相邻系统之间唯一地标识数据电路。</li>
</ol>
<h3 id="物理层主要功能">物理层主要功能</h3>
<ol type="1">
<li>为数据端设备提供传送数据的通路，数据通路可以是一个物理媒体，也可以是多个物理媒体连接而成。一次完整的数据传输，包括激活物理连接，传送数据，终止物理连接。所谓激活，就是不管有多少物理媒体参与，都要在通信的两个数据终端设备间连接起来，形成一条通路。</li>
<li>传输数据，物理层要形成适合数据传输需要的实体，为数据传送服务。一是要保证数据能在其上正确通过，二是要提供足够的带宽（带宽是指每秒钟内能通过的比特（BIT）数），以减少信道上的拥塞。传输数据的方式能满足点到点，一点到多点，串行或并行，半双工或全双工，同步或异步传输的需要。</li>
<li>完成物理层的一些管理工作。</li>
</ol>
<h3 id="物理层的接口特性">物理层的接口特性</h3>
<ol type="1">
<li>机械特性：<br>
  也叫物理特性，指明通信实体间硬件连接接口的机械特点，如接口所用接线器的形状和尺寸、引线数目和排列、固定和锁定装置等。这很像平时常见的各种规格的电源插头，其尺寸都有严格的规定。</li>
<li>电气特性：<br>
  规定了在物理连接上，导线的电气连接及有关电路的特性，一般包括：接收器和发送器电路特性的说明、信号的识别、最大传输速率的说明、与互连电缆相关的规则、发送器的输出阻抗、接收器的输入阻抗等电气参数等。</li>
<li>功能特性：<br>
  指明物理接口各条信号线的用途（用法），包括：接口线功能的规定方法，接口信号线的功能分类--数据信号线、控制信号线、定时信号线和接地线4类。</li>
<li>规程特性：<br>
  指明利用接口传输比特流的全过程及各项用于传输的事件发生的合法顺序，包括事件的执行顺序和数据传输方式。</li>
</ol>
<ul>
<li>以上4个特性实现了物理层在传输数据时，对于信号、接口和传输介质的规定。</li>
</ul>
<h3 id="信道的基本概念">信道的基本概念</h3>
<p>信道一般表示向一个方向传输信息的媒介。所以通信线路往往包含一条发送信息的信道和一条接收信息的信道。</p>
<ol type="1">
<li>单向通信(单工通信)——只能有一个方向的通信，没有反向交互。无线电广播或有线电广播以及电视广播就属于这种类型。</li>
<li>双向交替通信(半双工通信)——通信的双方都可以发送信息，但是不能双方同时发送或接收。</li>
<li>双向同时通信(全双工通信)——通信的双发可以同时发送和接收。</li>
</ol>
<h3 id="基带信号和带通信号">基带信号和带通信号</h3>
<ol type="1">
<li>基带信号：(基本频率信号)——来自信源的信号，例如计算机输出的代表各种文字或图像文件的数据信号都属于基带信号。基带信号就是发出的直接表达了要传输的信息的信号，比如说我们说话的声波。</li>
<li>带通信号：把基带信号经过载波<strong>调制</strong>后（载波频率高），把信号的频率范围迁移到较高的频段以便在信道中传输(即仅在一段频率范围内能够通过信道)。</li>
</ol>
<ul>
<li>因此在传输距离较近时，采用基带传输方式(衰减不大，信号内容不会变化)，传输距离较远时，采用带通传输方式。</li>
</ul>
<h3 id="调制与编码">调制与编码</h3>
<h3 id="奈氏准则">奈氏准则</h3>
<ol type="1">
<li>在假定的理想条件下，为了避免码间串扰，也就是<strong>没有噪声的干扰</strong>，码元的传输速率的上限值。</li>
<li>在任何信道中，码元传输的速率是有上限的，否则就会出现码间串扰的问题，使接收端对码元的判决（即识别）成为不可能。</li>
<li>如果信道的频带越宽，也就是能够通过的信号高频分量越多（在频分复用处可以体现出频带越宽，能够通过的频率上下界限越大，所携带的信息越多），那么就可以用更高的速率传送码元而不出现码间串扰。</li>
</ol>
<h3 id="香农公式">香农公式</h3>
<ol type="1">
<li>香农(Shannon)用信息论的理论推导出了带宽受限且有高斯白噪声干扰的信道的极限、无差错的信息传输速率。</li>
<li>信道的带宽或信道中的信噪比(S/N)越大，则信息的极限传输速率C就越高。</li>
<li>只要信息传输速率小于信道的极限传输速率C，就一定能实现某种无差错传输。</li>
<li>若带宽W或信噪比(S/N)没有上限，则极限传输速率C也没有上限(实际中不可能)。实际上，信道最高传输速率要比C低不少。</li>
</ol>
<h3 id="物理层下面的传输媒体">物理层下面的传输媒体</h3>
<ul>
<li>导向传输媒体和非导向传输媒体</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://wangwenlonggg.github.io/2021/05/22/%E4%B8%AD%E7%BB%A7%E5%99%A8%E3%80%81%E9%9B%86%E7%BA%BF%E5%99%A8(HUB)%E3%80%81%E7%BD%91%E6%A1%A5%E3%80%81%E4%BA%A4%E6%8D%A2%E6%9C%BA%E3%80%81%E8%B7%AF%E7%94%B1%E5%99%A8%E6%AF%94%E8%BE%83/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/laugh.jpg">
      <meta itemprop="name" content="wangwenlonggg">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wangwenlonggg">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/22/%E4%B8%AD%E7%BB%A7%E5%99%A8%E3%80%81%E9%9B%86%E7%BA%BF%E5%99%A8(HUB)%E3%80%81%E7%BD%91%E6%A1%A5%E3%80%81%E4%BA%A4%E6%8D%A2%E6%9C%BA%E3%80%81%E8%B7%AF%E7%94%B1%E5%99%A8%E6%AF%94%E8%BE%83/" class="post-title-link" itemprop="url">中继器、集线器(HUB)、网桥、交换机、路由器比较</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-05-22 09:06:18 / 修改时间：14:03:01" itemprop="dateCreated datePublished" datetime="2021-05-22T09:06:18+08:00">2021-05-22</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">计算机网络</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <ul>
<li>首先看一下这些网络设备分别处于计算机网络的哪些层次：</li>
</ul>
<table>
<thead>
<tr class="header">
<th>应用层</th>
<th>应用网关</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>传输层</td>
<td>传输网关</td>
</tr>
<tr class="even">
<td>网络层</td>
<td>路由器</td>
</tr>
<tr class="odd">
<td>数据链接层</td>
<td>网桥、交换机</td>
</tr>
<tr class="even">
<td>物理层</td>
<td>中继器、集线器（Hub）</td>
</tr>
</tbody>
</table>
<h3 id="中继器">中继器</h3>
<p>  中继器(Repeater)是连接网络线路的一种装置,常用于两个网络节点之间物理信号的双向转发工作。中继器是最简单的网络互联设备,主要完成物理层的功能,负责在两个节点的物理层上按位传递信息,完成信号的复制、调整和放大功能,以此来延长网络的长度。它在OSI参考模型中的位置物理层。<br>
  由于存在损耗, 在线路上传输的信号功率会逐渐衰减,衰减到一定程度时将造成信号失真,因此会导致接收错误。中继器就是为解决这一问题而设计的。<strong>它完成物理线路的连接,对衰减的信号进行放大,保持与原数据相同</strong>。<br>
  中继器是模拟设备，用于连接两根电缆段。中继器不理解帧、分组和头的概念，他们只理解电压值。</p>
<h3 id="集线器">集线器</h3>
<p>  集线器（Hub）是中继器的一种形式，区别在于集线器能够提供多端口服务，也称为多口中继器。</p>
<h3 id="网桥">网桥</h3>
<p>  <strong>网桥(Bridge)是一个局域网与另一个局域网之间建立连接的桥梁</strong>。网桥是属于数据链路层的一种设备，它的作用是扩展网络和通信手段，在各种传输介质中转发数据信号，扩展网络的距离，同时又有选择地将现有地址的信号从一个传输介质发送到另一个传输介质，并能有效地限制两个介质系统中无关紧要的通信。<br>
  网桥工作在数据链路层，将两个LAN连起来，根据MAC地址来转发帧，可以看作一个“低层的路由器”。</p>
<h3 id="交换机">交换机</h3>
<p>  交换机（Swich)工作在第二层（即数据链路层），它要比集线器智能一些，<strong>它能分辨出帧中的源MAC地址和目的MAC地址</strong>，因此可以在任意两个端口间建立联系，在数据帧的始发者和目标接收者之间建立临时的交换路径，使数据帧直接由源地址到达目的地址。交换机通过对信息进行重新生成，并经过内部处理后转发至指定端口，具备自动寻址能力和交换作用。但是 交换机并不懂得IP地址，它只知道MAC地址。<br>
  交换机，可以理解为高级的网桥，他有网桥的功能，但性能比网桥强。交换机和网桥的细微差别就在于：<strong>交换机常常用来连接独立的计算机，而网桥连接的目标是LAN，所以交换机的端口较网桥多</strong>。</p>
<h3 id="路由器">路由器</h3>
<p>  路由器（Router)工作在第三层（即网络层），它比交换机还要“聪明”一些，它能理解数据中的IP地址，如果它接收到一个数据包，就检查其中的IP地址，如果目标地址是本地网络的就不理会，如果是其他网络的，就将数据包转发出本地网络。与工作在网络物理层，从物理上划分网段的交换机不同，<strong>路由器使用专门的软件协议从逻辑上对整个网络进行划分</strong>。例如，一台支持IP协议的路由器可以把网络划分成多个子网段，只有指向特殊IP地址的网络流量才可以通过路由器。当IP子网中的一台主机发送IP分组给同一IP子网的另一台主机时，它将直接把IP分组送到网络上，对方就能收到。而要送给不同IP于网上的主机时，它要选择一个能到达目的子网上的路由器，把IP分组送给该路由器，由路由器负责把IP分组送到目的地。如果没有找到这样的路由器，主机就把IP分组送给一个称为“缺省网关（default gateway）”的路由器上。对于每一个接收到的数据包，路由器都会重新计算其校验值，并写入新的物理地址。网络中的设备用它们的网络地址（TCP／IP网络中为IP地址）互相通信。IP地址是与硬件地址无关的“逻辑”地址。<br>
  <strong>路由器用于连接多个逻辑上分开的网络，几个使用不同协议和体系结构的网络</strong>。路由器利用网络层定义的“逻辑”上的网络地址（即IP地址）来区别不同的网络，实现网络的互连和隔离，保持各个网络的独立性。当一个子网传输到另外一个子网时，可以用路由器完成。它具有判断网络地址和选择路径的功能，过滤和分隔网络信息流。一方面能够跨越不同的物理网络类型（DDN、FDDI、以太网等等），另一方面在逻辑上将整个互连网络分割成逻辑上独立的网络单位，使网络具有一定的逻辑结构。</p>
<h3 id="网关">网关</h3>
<p>  网关(Gateway)又称<strong>网间连接器、协议转换器</strong>。网关在网络层以上实现网络互连，是最复杂的网络互连设备，仅用于两个高层协议不同的网络互连。网关既可以用于广域网互连，也可以用于局域网互连。 网关是一种充当转换重任的计算机系统或设备。使用在不同的通信协议、数据格式或语言，甚至体系结构完全不同的两种系统之间，<strong>网关是一个翻译器</strong>。与网桥只是简单地传达信息不同，网关对收到的信息要重新打包，以适应目的系统的需求。</p>
<hr>
<h3 id="中继器或集线器既不能隔离冲突域又不能隔离广播域网桥或交换机只能隔离冲突域不能隔离广播域路由器既能隔离冲突域又能隔离广播域为什么">中继器或集线器既不能隔离冲突域又不能隔离广播域，网桥或交换机只能隔离冲突域不能隔离广播域，路由器既能隔离冲突域又能隔离广播域，为什么？</h3>
<p>  首先要清楚什么是冲突域和广播域，当一块网卡发送信息时有可能和另一块网卡冲突的所有的网卡的集合称为冲突域。一块网卡发出一个广播，能收到这个广播的所有的网卡的集合称为一个广播域。一般来说一个网段就是一个冲突域，一个局域网就是一个广播域。</p>
<ul>
<li><p>集线器：<br>
  中继器就是普通集线器的前身，集线器实际就是一种多端口的中继器。集线器一般有4、8、16、24、32等数量的RJ45接口，通过这些接口，集线器便能为相应数量的电脑完成“中继”功能。由于它在网络中处于一种“中心”位置，因此集线器也叫做“Hub”。 集线器的工作原理很简单，假设有一个8个接口的集线器，共连接了8台电脑。集线器处于网络的“中心”，通过集线器对信号进行转发，8台电脑之间可以互连互通。具体通信过程是这样的：假如计算机1要将一条信息发送给计算机8，当计算机1的网卡将信息通过双绞线送到集线器上时，集线器并不会直接将信息送给计算机8，它会将信息进行“广播”——将信息同时发送给8个端口，当8个端口上的计算机接收到这条广播信息时，会对信息进行检查，如果发现该信息是发给自己的，则接收，否则不予理睬。由于该信息是计算机1发给计算机8的，因此最终计算机8会接收该信息，而其它7台电脑看完信息后，会因为信息不是自己的而不接收该信息，大家用一个现实生活的例子来联想，假如你在出差，有一个陌生来电，接了之后你却发现打错了，要花费不少漫游费，你生不生气？当然很生气（冲突），所以集线器所有端口都属于一个冲突域，故集线器不能分割冲突域。集线器在一个时钟周期中只能传输一组信息，如果一台集线器连接的机器数目较多，并且多台机器经常需要同时通信时，将导致集线器的工作效率很差，如发生信息堵塞、碰撞等。为什么会这样呢?打给比方，一个集线器连接8台计算机，当计算机1正在通过集线器发信息给计算机8时，如果此时计算机2也想通过集线器将信息发给计算机7，当它试图与集线器联系时，却发现集线器正在忙计算机1的事情，于是计算机2便会“带”着数据站在集线器的面前等待，并时时要求集线器停下计算机1的活来帮自己干。如果计算机2成功地将集线器“抢”过来了（由于集线器是“共享”的，因此很容易抢到手），此时正处于传输状态的计算机1的数据便会停止，于是计算机1也会去 “抢”集线器，可见，集线器上每个端口的真实速度除了与集线器的带宽有关外，与同时工作的设备数量也有关。比如说一个带宽为10Mb的集线器上连接了8台计算机，当这8台计算机同时工作时，则每台计算机真正所拥有的带宽是10/8=1.25Mb。</p></li>
<li><p>交换机：<br>
  交换机也叫交换式集线器，它通过对信息进行重新生成，并经过内部处理后转发至指定端口，具备自动寻址能力和交换作用，由于交换机根据所传递信息包的目的地址，将每一信息包独立地从源端口送至目的端口，避免了和其他端口发生碰撞。简单的说就是，交换机某端口连接的主机想和另一个端口连接的主机通信，交换机就会通过转发表发送那个端口，不可能去其他端口，不存在发错端口（即打错电话），所以交换机的每一个端口都是一个<strong>冲突域</strong>，也就是说交换机可以<strong>隔离冲突域</strong>。交换机的工作原理：在计算机网络系统中，交换机是针对共享工作模式的弱点而推出的。集线器是采用共享工作模式的代表，如果把集线器比作一个邮递员，那么这个邮递员是个不认识字的“傻瓜”，如要要他去送信，他不知道直接根据信件上的地址将信件送给收信人，只会拿着信分发给所有的人，然后让接收的人根据地址信息来判断是不是自己的，而交换机则是一个“聪明”的邮递员——交换机拥有一条高带宽的背部总线和内部交换矩阵。交换机的所有的端口都挂接在这条背部总线上，当控制电路收到数据包以后，处理端口会查找内存中的地址对照表以确定目的MAC地址应该从哪个端口发出，通过内部交换矩阵迅速将数据包传送到目的端口。目的MAC地址若不存在，交换机才广播到所有的端口，接收端口回应后交换机会“学习”新的地址，并把它添加入内部地址表中。可见，交换机在收到某个网卡发过来的“信件”时，会根据上面的地址信息，以及自己掌握的“常住居民户口簿”快速将信件送到收信人的手中。万一收信人的地址不在“户口簿”上，交换机才会像集线器一样将信分发给所有的人，然后从中找到收信人。而找到收信人之后，交换机会立刻将这个人的信息登记到“户口簿”上，这样以后再为该客户服务时，就可以迅速将信件送达了。<br>
  由于交换机能够智能化地根据地址信息将数据快速送到目的地，因此它不会像集线器那样在传输数据时“打扰”那些非收信人。这样一来，交换机在同一时刻可进行多个端口组之间的数据传输。并且每个端口都可视为是独立的网段，相互通信的双方独自享有全部的带宽，无须同其他设备竞争使用。比如说，当A主机向D主机发送数据时，B主机可同时向C主机发送数据，而且这两个传输都享有网络的全部带宽——假设此时它们使用的是10M的交换机，那么该交换机此时的总流通量就等于2×10Mb=20Mb。</p></li>
<li><p>路由器：<br>
  前面我们已经讲过中继器或集线器不能隔离冲突域，交换机可以隔离冲突域，自然路由肯定也可以隔离冲突域（因为也有一张转发表去转发）；下面来讨论一下广播域。首先前面说了广播其实可以看成一个单独的网络，如果一个主机要发送一个广播数据，这样就应该在整个网络都可以听得见，但是<strong>集线器和交换机分别工作在物理层和数据链路层，不能连接两个不同的网络</strong>，所以说不管是集线器还是交换机遇到广播数据都要每个端口发一遍（因为每个端口连接的网络仍然是属于同一个网络），这样的话又存在打错电话的情况了，所以集线器和交换机不能隔离广播域，但是路由器可以连接不同的网络，且路由器在默认情况下是不转发广播报文的（因为每个端口连接的是不同的网络），故路由器的每一个端口都是一个广播域，故路由器可以隔离广播域。</p></li>
<li><p>尽管交换机也叫作多端口网桥，但是交换机和网桥还是有不同之处，下面一一列出：</p></li>
</ul>
<ol type="1">
<li>网桥的端口一般连接局域网，而交换机的端口一般直接与局域网的主机相连。</li>
<li>交换机允许多对计算机同时通信，而网桥允许每个网段上的计算机同时通信。</li>
<li>网桥采用存储转发形式进行转发，而以太网交换机还可以采用直通方式进行转发，且以太网交换机采用了专用的交换机构芯片，转发速度比网桥快。</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://wangwenlonggg.github.io/2021/05/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/laugh.jpg">
      <meta itemprop="name" content="wangwenlonggg">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wangwenlonggg">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B/" class="post-title-link" itemprop="url">计算机网络体系结构与参考模型</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-05-21 10:29:00 / 修改时间：15:31:17" itemprop="dateCreated datePublished" datetime="2021-05-21T10:29:00+08:00">2021-05-21</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">计算机网络</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="计算机网络体系结构">计算机网络体系结构</h1>
<h3 id="概念">概念</h3>
<ul>
<li>网络体系结构是从<strong>功能</strong>上描述计算机网络结构。</li>
<li>计算机网络体系结构是<strong>分层结构</strong>。</li>
<li>每层遵循某些<strong>网络协议</strong>以完成本层功能。</li>
<li>计算机网络体系结构是计算机网络的<strong>各层及其协议</strong>的集合。</li>
<li>第n层向n+1层提供服务时，此服务不仅包含第n层本身的功能，还包括由下层服务提供的功能。</li>
<li>仅仅在相邻层间有接口，且所提供服务的具体实现细节对上一层完全屏蔽。</li>
</ul>
<h3 id="计算机网络分层">计算机网络分层</h3>
<ul>
<li><p>无论是体系结构中的哪一层，都不是针对具体设备或者具体软件而言，而只是针对每层中所要实现的网络服务功能来划分的；每一层所代表的是一组网络功能。</p></li>
<li><p>分层基本原则：</p></li>
</ul>
<hr>
<ol type="1">
<li>同一层中的各网络节点都有相同的层次结构，具有同样的功能。</li>
<li>同一节点内相邻层之间通过接口通信。</li>
<li>七层结构中的每一层使用下一层提供的服务，并向上层提供服务。</li>
<li>不同节点的同等层按照协议实现<strong>对等层</strong>之间的通信</li>
</ol>
<hr>
<h3 id="协议">协议</h3>
<ol type="1">
<li>概念：为进行网络中的<strong>对等实体</strong>数据交换而建立的规则、标准或约定称为网络协议。</li>
<li>组成：</li>
</ol>
<ul>
<li>语法规定了传输数据的格式。</li>
<li>语义规定了所要完成的功能，即需要发出何种控制信息、完成何种动作及做出何种应答。</li>
<li>同步规定了执行各种操作的条件、时序关系等，即事件实现顺序的详细说明。</li>
</ul>
<ol start="3" type="1">
<li>功能：一个完整的协议通常具有线路管理（建立、释放连接）、错差控制、数据转换等功能。</li>
</ol>
<h3 id="接口">接口</h3>
<ul>
<li>接口是同一结点内相邻两层间交换信息的连接点，是一个系统内部的规定。每层只能为紧邻的层次之间定义接口，不能跨层定义接口。在典型的接口上，同一结点相邻两层的实体通过<strong>服务访问点（Service Access Point,SAP）</strong>进行交互。服务是通过SAP提供给上层使用的，第n层的SAP就是n+1层可以访问第n层服务的地方。每个SAP都有一个能够表示它的地方。SAP是一个抽象的概念，它实际上是一个逻辑接口，和通常所说的两个设备之间的硬件接口是很不一样的。</li>
</ul>
<h3 id="服务">服务</h3>
<ul>
<li>服务是指下层为紧邻的上层提供的功能调用，它是垂直的。对等实体在协议的控制下，使得本层能为上一层提供服务，但要实现本层协议还需要使用下一层所提供的服务。</li>
</ul>
<h1 id="参考模型">参考模型</h1>
<h3 id="osi参考模型">OSI参考模型</h3>
<p><strong>国际标准化组织（ISO）于1984年提出开放系统互连（OSI）参考模型</strong>。<br>
OSI七层：<strong>物链网输会示用</strong>；低三层是通信子网，高四层是资源子网。</p>
<ol type="1">
<li>通信子网（点到点）：由各种传输介质、通信设备和相应的网络协议组成，它使网络具有数据传输、交换、控制和存储的能力，实现联网计算机之间的通信。</li>
<li>资源子网（端到端）：实现资源共享功能的设备及其软件的集合向网络用户提供共享其他计算机上的资源服务。</li>
</ol>
<hr>
<ul>
<li><p>应用层：提供各种网络应用接口</p></li>
<li><p>表示层：数据表示、压缩与加密</p></li>
<li><p>会话层：主机间的会话管理</p></li>
<li><p>传输层：端到端的可靠设备</p></li>
<li><p>网络层：为不同网络间的主机通信提供网络寻址和路由转发；以分组为基本格式提供流量控制、拥塞控制和差错控制。</p></li>
<li><p>数据链路层：相邻节点间的可靠传输；<strong>同一局域网内部</strong>的网络/数据通信提供<strong>点对点</strong>的数据传输通道，通过MAC地址寻址把数据转到目的节点。</p></li>
<li><p>物理层：二进制比特流的<strong>透明传输</strong>；用来构建计算机网络通信和数据传输的通道，不针对具体的传输介、设备和通信协议，只要能实现物理层的某种功能就行了。</p></li>
</ul>
<hr>
<h3 id="计算机网络体系结构通信原理">计算机网络体系结构通信原理</h3>
<ul>
<li>发送端自上而下，接收端自下而上。</li>
<li>通信会话方面双方都必须是逻辑上的对等层次，也就就对等通信原理相同，发送端网络层只能与接收端网路层通信，不能交错通信。（只有双方是对等层次的会话才可能使用相同类型的协议）</li>
</ul>
<h3 id="各层上传输的数据格式">各层上传输的数据格式</h3>
<ul>
<li>对等层之间传送的数据单位称为PDU（Protocol Data Unit，协议数据单元）</li>
</ul>
<ol type="1">
<li>物理层：比特流格式</li>
<li>数据链路层：帧，一个帧包括多个比特，但大小必须是一个整数字节，不同协议的帧大小也不一样。（DPDU）</li>
<li>网络层：分组或包，一个分组包括多个帧，不同协议的分组大小也不一样。（NPDU）</li>
<li>传输层：数据段（TCP）；数据报（UDP）</li>
<li>会话层、表示层、应用层：数据报文</li>
</ol>
<h3 id="协议头和协议尾的封装">协议头和协议尾的封装</h3>
<ul>
<li>只有数据链路层不仅需要封装协议头，还要封装协议尾。</li>
<li>协议头用来封装PDU；协议尾代表本层封装结束。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://wangwenlonggg.github.io/2021/05/20/3D-reconstruction%EF%BC%88%E4%B8%80%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/laugh.jpg">
      <meta itemprop="name" content="wangwenlonggg">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wangwenlonggg">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/20/3D-reconstruction%EF%BC%88%E4%B8%80%EF%BC%89/" class="post-title-link" itemprop="url">3D reconstruction（一）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-05-20 19:59:31" itemprop="dateCreated datePublished" datetime="2021-05-20T19:59:31+08:00">2021-05-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-24 17:20:23" itemprop="dateModified" datetime="2021-05-24T17:20:23+08:00">2021-05-24</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/3D-reconstruction/" itemprop="url" rel="index"><span itemprop="name">3D reconstruction</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="三维模型的表示方法">三维模型的表示方法</h2>
<ol type="1">
<li>点云：</li>
</ol>
<ul>
<li>点云是在同一空间参考系下表达目标空间分布和目标表面特性的海量点集合。</li>
<li>结合激光测量和摄影测量原理得到点云，包括<strong>三维坐标（XYZ）、激光反射强度（Intensity）和颜色信息（RGB）。</strong></li>
<li>在获取物体表面每个采样点的空间坐标后，得到的是一个点的集合，称之为"点云"。</li>
</ul>
<ol start="2" type="1">
<li>网格(mesh)：</li>
</ol>
<ul>
<li>多边形网格（Polygon mesh）是三维计算机图形学中表示多面体形状的顶点与多边形的集合，它也叫作<strong>非结构网格。</strong></li>
<li>这些网格通常由三角形、四边形或者其它的简单凸多边形组成，这样可以简化渲染过程。但是，网格也可以包括带有空洞的普通多边形组成的物体。</li>
</ul>
<ol start="3" type="1">
<li>体素(voxel)：</li>
</ol>
<ul>
<li>体素是体积像素(volume pixel)的简称。</li>
<li>如同像素，体素本身并不含有空间中位置的数据即（它们的坐标），却可以从它们相对于其它体素的位置来推敲，意即它们在构成单一张体积影像的数据结构中的位置。</li>
</ul>
<ol start="4" type="1">
<li>深度图：</li>
</ol>
<ul>
<li>深度图像也被称为距离影像，是指将从图像采集器到场景中各点的距离（深度）作为像素值的图像，它直接反映了景物可见表面的几何形状。</li>
<li>深度图像经过坐标转换可以计算为点云数据，有规则及必要信息的点云数据也可以反算为深度图像数据。</li>
<li>深度值的大小只与距离有关，而与环境、光线、方向等因素无关。</li>
</ul>
<h2 id="三维重建比较常见的流程">三维重建比较常见的流程</h2>
<ul>
<li>提取图像特征--&gt;利用特征将图像计算图像之间的特征匹配--&gt;基于匹配的特征进行稀疏重建，得到各个图像的相机位姿和稀疏的特征点云--&gt;基于相机位姿进行稠密重建，得到稠密点云--&gt;基于点云重建网格、体素或者纹理</li>
</ul>
<h2 id="三维重建技术方法">三维重建技术方法</h2>
<ul>
<li><strong>三维重建技术的重点在于如何获取目标场景或物体的深度信息。在景物深度信息已知的条件下，只需要经过点云数据的配准及融合，即可实现景物的三维重建。</strong></li>
<li>人们按照被动式测量与主动式测量对目标物体深度信息的获取方法进行了分类：</li>
</ul>
<h3 id="被动式三维重建技术">被动式三维重建技术</h3>
<ul>
<li>被动式一般利用周围环境如自然光的反射，使用相机获取图像，然后通过特定算法计算得到物体的立体空间信息。主要有以下三种方法：</li>
</ul>
<ol type="1">
<li>纹理恢复形状法</li>
</ol>
<ul>
<li>作为图像视野中不断重复的视觉基元，纹理元覆盖在各个位置和方向上。当某个布满纹理元的物体被投射在平面上时，其相应的纹理元也会发生弯折与变化。</li>
<li>例如透视收缩变形使与图像平面夹角越小的纹理元越长，投影变形会使离图像平面越近的纹理元越大。通过对图像的测量来获取变形，进而根据变形后的纹理元，逆向计算出<strong>深度数据。</strong></li>
</ul>
<ol start="2" type="1">
<li>阴影恢复形状法</li>
</ol>
<ul>
<li>图像的阴影边界包含了图像的轮廓特征信息，因此能够利用不同光照条件下的图像的明暗程度与阴影来计算物体表面的<strong>深度信息</strong>，并以反射光照模型进行三维重建。</li>
</ul>
<ol start="3" type="1">
<li>立体视觉法（MVS）</li>
</ol>
<ul>
<li>主要包括直接利用测距器获取程距信息、通过一幅图像推测三维信息和利用不同视点上的两幅或多幅图像恢复三维信息等三种方式。</li>
</ul>
<h3 id="主动式三维重建技术">主动式三维重建技术</h3>
<ul>
<li>主动式是指利用如激光、声波、电磁波等光源或能量源发射至目标物体，通过接收返回的光波来获取物体的<strong>深度信息</strong>。</li>
</ul>
<ol type="1">
<li>飞行时间法（ToF）</li>
</ol>
<ul>
<li>通过测量发射信号与接收信号的飞行时间间隔来获得距离的方法。</li>
</ul>
<ol start="2" type="1">
<li>结构光法</li>
</ol>
<ul>
<li>结构光是将已知图案（通常是栅格或水平条）投射到场景上的过程。这些物体在撞击表面时变形的信息来在视觉系统中计算场景中物体的深度和表面信息，用投影仪投射特定的光信息到物体表面后及背景后，由摄像头采集。根据物体造成的光信号的变化来计算物体的位置和深度等信息，进而复原整个三维空间。</li>
<li>首先利用激光投影仪向目标物体投射可编码的光束，生成特征点；然后根据投射模式与投射光的几何图案，通过三角测量原理计算摄像机光心与特征点之间的距离，由此便可获取生成特征点的深度信息，实现模型重建。这种可编码的光束就是结构光。</li>
</ul>
<ol start="3" type="1">
<li>三角测距法</li>
</ol>
<ul>
<li>红外设备以一定的角度向物体投射红外线，光遇到物体后发生反射并被CCD图像传感器所检测。随着目标物体的移动，此时获取的反射光线也会产生相应的偏移值。根据发射角度、偏移距离、中心矩值和位置关系，便能计算出发射器到物体之间的距离。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://wangwenlonggg.github.io/2021/05/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/laugh.jpg">
      <meta itemprop="name" content="wangwenlonggg">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wangwenlonggg">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/" class="post-title-link" itemprop="url">计算机网络概述</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-05-20 10:53:23" itemprop="dateCreated datePublished" datetime="2021-05-20T10:53:23+08:00">2021-05-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-21 10:20:32" itemprop="dateModified" datetime="2021-05-21T10:20:32+08:00">2021-05-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">计算机网络</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="一计算机网络性能指标"><strong>一、计算机网络性能指标</strong></h1>
<h2 id="速率">1、速率：</h2>
<p>（1）、速率即数据率或称数据传输率或比特率。<br>
（2）、连接在计算机网络上的主机在数字信道上传送数据位数的速率，单位是b/s kb/s Mb/s。</p>
<h2 id="带宽">2、带宽：</h2>
<ul>
<li>带宽原本指某个信号具有的频带宽度，即<strong>最高频率与最低频率之差</strong>，单位是赫兹（Hz）。</li>
<li>计算机网络中，带宽用来指网络系统的通信链路（信道或者传输媒体）传输数据的能力，即表征单位时间内从网络中的某一点到另一点所能通过的"最高数据率"。</li>
<li>强调网络最大的数据传输速率，即传输数据率理论峰值。</li>
</ul>
<h2 id="吞吐量">3、吞吐量：</h2>
<p>（1）、表示在<strong>单位时间</strong>内通过<strong>某个网络或信道、接口</strong>的数据量，单位是b/s kb/s Mb/s。<br>
（2）、吞吐量受网络的带宽或网络的额定速率的限制。</p>
<h2 id="时延">4、时延：</h2>
<ul>
<li>指数据（一个报文或分组）从网络（或链路）的一端传送到另一端所需要的总时间，它由4 部分构成：发送时延、传播时延、处理时延、排队时延。</li>
<li>总时延=发送时延+传播时延+处理时延+排队时延</li>
</ul>
<h3 id="发送时延">（1）、发送时延：</h3>
<ul>
<li>结点将分组的所有比特推向（传输）链路所需要的时间，即从发送分组的第一个比特算起，到该分组的最后一个比特推向传输链路所需要的时间。也称传输时延。</li>
</ul>
<p><span class="math display">\[
发送时延 = \frac{分组长度(数据长度)}{信道宽度(发送速率)}
\]</span></p>
<h3 id="传播时延">（2）、传播时延：</h3>
<ul>
<li>电磁波在信道中传播一定的距离需要花费的时间，即一个比特从链路的一端传播到另一端所需要的时间。</li>
</ul>
<p><span class="math display">\[
传播时延 = \frac{信道长度(链路长度)}{电磁波在信道中的传播速率(2\times 10^{8}左右)}
\]</span></p>
<h3 id="排队时延">（3）、排队时延：</h3>
<p>分组在进入路由器后要先在输入队列中排队等待处理。</p>
<h3 id="处理时延">（4）、处理时延：</h3>
<p>数据在交换结点为存储转发而进行的一些必要的处理所花费的时间。</p>
<h3 id="时延带宽积">（5）、时延带宽积：</h3>
<ul>
<li>发送端发送的第一个比特即将到达终点时，发送端已经发出了多少个比特。</li>
<li>时延带宽积又称为以比特为单位的链路长度；即某段链路现在有多少比特。</li>
</ul>
<p><span class="math display">\[
时延带宽积 = {传播时延}\times{信道带宽}
\]</span></p>
<h3 id="往返时延rtt">（6）、往返时延（RTT）：</h3>
<p>从发送方发送数据开始，到发送方收到接受方的确认（接收方收到数据后立即发送确认），总共经历的时延。<br>
<strong>RTT越大，在收到确认之前，可以发送的数据越多。</strong></p>
<h3 id="信道利用率">（7）、信道利用率：</h3>
<p><span class="math display">\[
信道利用率 = \frac{有数据通过时间}{(有 + 无)数据通过时间}
\]</span></p>
<ul>
<li><strong>信道利用率越高时延越大</strong>。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://wangwenlonggg.github.io/2021/05/18/hello-world/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/laugh.jpg">
      <meta itemprop="name" content="wangwenlonggg">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wangwenlonggg">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/18/hello-world/" class="post-title-link" itemprop="url">Hello World</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-05-18 09:35:11" itemprop="dateCreated datePublished" datetime="2021-05-18T09:35:11+08:00">2021-05-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-20 10:55:47" itemprop="dateModified" datetime="2021-05-20T10:55:47+08:00">2021-05-20</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="quick-start">Quick Start</h2>
<h3 id="create-a-new-post">Create a new post</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="run-server">Run server</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="generate-static-files">Generate static files</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="deploy-to-remote-sites">Deploy to remote sites</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="wangwenlonggg"
      src="/images/laugh.jpg">
  <p class="site-author-name" itemprop="name">wangwenlonggg</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">7</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">wangwenlonggg</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
